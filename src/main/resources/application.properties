server.port=${PORT:8080}

# Database Configuration (PostgreSQL)
spring.datasource.url=${DB_URL}
spring.datasource.username=${DB_USERNAME}
spring.datasource.password=${DB_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver
# HikariCP enhanced Pool settings
spring.datasource.hikari.maximum-pool-size=50
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.connection-timeout=300000
spring.datasource.hikari.auto-commit=true
spring.datasource.hikari.pool-name=ActivationAutomationHikariPool

# JPA / Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.show-sql=false

# Redis Configuration
spring.redis.host=${REDIS_HOST:localhost}
spring.redis.port=${REDIS_PORT:6379}
# If using URL connection string in properties, you'd need a custom config to parse it, 
# or use spring.redis.url if supported by your version (Spring Data Redis 2.x+ supports spring.redis.url)
spring.redis.url=${REDIS_URL_DEV}

# Redis Pool Configuration
spring.data.redis.lettuce.pool.max-active=8
spring.data.redis.lettuce.pool.max-idle=8
spring.data.redis.lettuce.pool.min-idle=0
spring.data.redis.lettuce.pool.max-wait=-1ms

# Mail Configuration
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=${EMAIL_USER}
spring.mail.password=${EMAIL_PASS}
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true

# Application Custom Properties
app.env-mode=${ENV_MODE:dev}
app.bcrypt-cost-factor=${BCRYPT_COST_FACTOR:10}

app.jwt.secret=${JWT_SECRET}
app.jwt.access-expiration-minutes=${JWT_ACCESS_EXPIRATION_MINUTES:30}
app.jwt.refresh-expiration-days=${JWT_REFRESH_EXPIRATION_DAYS:30}

app.azure.account-name=${ACCOUNT_NAME}
app.azure.account-key-part1=${ACCOUNT_KEY_PART1}
app.azure.account-key-part2=${ACCOUNT_KEY_PART2}
app.azure.endpoint-suffix=${ENDPOINT_SUFFIX}
app.azure.default-endpoints-protocol=${DEFAULT_ENDPOINTS_PROTOCOL:http}

app.email.user=${EMAIL_USER}
app.email.pass=${EMAIL_PASS}

app.gcp.bucket-private-key-id=${GCP_BUCKET_PRIVATE_KEY_ID}
app.gcp.bucket-private-key=${GCP_BUCKET_PRIVATE_KEY}

app.ai-backend-url=${AI_BACKEND_URL}
app.ai-backend-secret-key=${AI_BACKEND_SECRET_KEY}
app.default-gcs-url=${DEFAULT_GCS_URL:https://shelfex-cdn.storage.googleapis.com/automation-activation}
app.default-profile-img-url=${DEFAULT_PROFILE_IMG_URL:https://storage.googleapis.com/shelfex-cdn/portal/own/images/profile_img.jpg}
app.default-admin-id=${DEFAULT_ADMIN_ID:1}
app.frontend-url=${FRONTEND_URL}
app.go-backend-url=${GO_BACKEND_URL}

app.redis-url-dev=${REDIS_URL_DEV}
app.redis-url-prod=${REDIS_URL_PROD}

# Logging (Pino logic equivalent)
logging.file.path=./logs
logging.file.name=./logs/info.log
logging.level.root=INFO
logging.level.com.shelfpulse=DEBUG
# In Spring Boot, you'd typically use logback-spring.xml for advanced splitting (error vs info files)
# For now, this basic config handles standard logging.

# Multipart (Multer equivalent)
spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# Jackson Configuration
spring.jackson.serialization.write-dates-as-timestamps=false
